import projectConfig from '/pagic.config.js';
import Gitalk from '/_gitalk.js';
export default {
    'prev': {
        "text": "移动端常见问题",
        "link": "start/Mobile.html"
    },
    'next': {
        "text": "代码重构经验",
        "link": "start/Codeing.html"
    },
    config: { "root": "/", ...projectConfig, branch: 'master' },
    'pagePath': "start/Performance.md",
    'layoutPath': "_layout.tsx",
    'outputPath': "start/Performance.html",
    'title': "性能优化",
    'content': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<h1 id="%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">性能优化<a class="anchor" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">§</a></h1>\n<h2 id="%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3">网络相关<a class="anchor" href="#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3">§</a></h2>\n<h3 id="dns-%E9%A2%84%E8%A7%A3%E6%9E%90">DNS 预解析<a class="anchor" href="#dns-%E9%A2%84%E8%A7%A3%E6%9E%90">§</a></h3>\n<p>DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。</p>\n<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dns-prefetch<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>//yuchengkai.cn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n</code></pre>\n<h3 id="%E7%BC%93%E5%AD%98">缓存<a class="anchor" href="#%E7%BC%93%E5%AD%98">§</a></h3>\n<p>缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。</p>\n<p>通常浏览器缓存策略分为两种：强缓存和协商缓存。</p>\n<h4 id="%E5%BC%BA%E7%BC%93%E5%AD%98">强缓存<a class="anchor" href="#%E5%BC%BA%E7%BC%93%E5%AD%98">§</a></h4>\n<p>实现强缓存可以通过两种响应头实现：<code>Expires</code> 和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，<code>state code</code> 为 200</p>\n<pre class="language-js"><code class="language-js"><span class="token maybe-class-name">Expires</span><span class="token operator">:</span> <span class="token maybe-class-name">Wed</span><span class="token punctuation">,</span> <span class="token number">22</span> <span class="token maybe-class-name">Oct</span> <span class="token number">2018</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">41</span><span class="token operator">:</span><span class="token number">00</span> <span class="token constant">GMT</span>\n</code></pre>\n<p><code>Expires</code> 是 HTTP / 1.0 的产物，表示资源会在 <code>Wed, 22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。并且 <code>Expires</code> 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p>\n<pre class="language-js"><code class="language-js"><span class="token maybe-class-name">Cache</span><span class="token operator">-</span>control<span class="token operator">:</span> max<span class="token operator">-</span>age<span class="token operator">=</span><span class="token number">30</span>\n</code></pre>\n<p><code>Cache-Control</code> 出现于 HTTP / 1.1，优先级高于 <code>Expires</code> 。该属性表示资源会在 30 秒后过期，需要再次请求。</p>\n<h4 id="%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98">协商缓存<a class="anchor" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98">§</a></h4>\n<p>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。</p>\n<p>协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。</p>\n<h5 id="last-modified-%E5%92%8C-if-modified-since">Last-Modified 和 If-Modified-Since<a class="anchor" href="#last-modified-%E5%92%8C-if-modified-since">§</a></h5>\n<p><code>Last-Modified</code> 表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified</code> 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。</p>\n<p>但是如果在本地打开缓存文件，就会造成 <code>Last-Modified</code> 被修改，所以在 HTTP / 1.1 出现了 <code>ETag</code> 。</p>\n<h5 id="etag-%E5%92%8C-if-none-match">ETag 和 If-None-Match<a class="anchor" href="#etag-%E5%92%8C-if-none-match">§</a></h5>\n<p><code>ETag</code> 类似于文件指纹，<code>If-None-Match</code> 会将当前 <code>ETag</code> 发送给服务器，询问该资源 <code>ETag</code> 是否变动，有变动的话就将新的资源发送回来。并且 <code>ETag</code> 优先级比 <code>Last-Modified</code> 高。</p>\n<h4 id="%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5">选择合适的缓存策略<a class="anchor" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5">§</a></h4>\n<p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p>\n<ul>\n<li>对于某些不需要缓存的资源，可以使用 <code>Cache-control: no-store</code> ，表示该资源不需要缓存</li>\n<li>对于频繁变动的资源，可以使用 <code>Cache-Control: no-cache</code> 并配合 <code>ETag</code> 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li>\n<li>对于代码文件来说，通常使用 <code>Cache-Control: max-age=31536000</code> 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li>\n</ul>\n<h3 id="%E4%BD%BF%E7%94%A8-http--20">使用 HTTP / 2.0<a class="anchor" href="#%E4%BD%BF%E7%94%A8-http--20">§</a></h3>\n<p>因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间。</p>\n<p>在  HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。</p>\n<h3 id="%E9%A2%84%E5%8A%A0%E8%BD%BD">预加载<a class="anchor" href="#%E9%A2%84%E5%8A%A0%E8%BD%BD">§</a></h3>\n<p>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。</p>\n<p>预加载其实是声明式的 <code>fetch</code> ，强制浏览器请求资源，并且不会阻塞 <code>onload</code> 事件，可以使用以下代码开启预加载</p>\n<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>preload<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><a class="token url-link" href="http://example.com">http://example.com</a><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n</code></pre>\n<p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</p>\n<h3 id="%E9%A2%84%E6%B8%B2%E6%9F%93">预渲染<a class="anchor" href="#%E9%A2%84%E6%B8%B2%E6%9F%93">§</a></h3>\n<p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染</p>\n<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>prerender<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><a class="token url-link" href="http://example.com">http://example.com</a><span class="token punctuation">"</span></span><span class="token punctuation">></span></span> \n</code></pre>\n<p>预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染</p>\n<h2 id="pwa-%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98">PWA 离线缓存<a class="anchor" href="#pwa-%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98">§</a></h2>\n<h3 id="%E4%B8%BB%E7%BA%BF%E7%A8%8B">主线程<a class="anchor" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B">§</a></h3>\n<p><code>ServiceWorker</code>既然命名为<code>worker</code>，很大一部分原因就是它和<code>WebWorker</code>相关。它是第二个线程，不会影响 dom 渲染的主线程，两个<code>Worker</code>之间的通讯是基于<code>postMessage</code>。\n<code>chrome://inspect/#service-workers</code> 就可以查看，在当前浏览器中，正在注册的 <code>SW</code>。另外，还有一个 <code>chrome://serviceworker-internals</code>，用来查看当前浏览器中，所有注册好的 <code>SW</code>。</p>\n<h3 id="%E5%9F%BA%E4%BA%8E-https">基于 HTTPS<a class="anchor" href="#%E5%9F%BA%E4%BA%8E-https">§</a></h3>\n<p><code>SW</code> 是基于 <code>HTTPS</code> 的，如果你的网站不是 <code>HTTPS</code>，那么基本上你也别想了 <code>SW</code>。</p>\n<h3 id="scope-%E4%BD%9C%E7%94%A8%E5%9F%9F">Scope 作用域<a class="anchor" href="#scope-%E4%BD%9C%E7%94%A8%E5%9F%9F">§</a></h3>\n<p>一个<code>sw.js</code>并不能接管一个站点所有的页面，它只能在所在路由底下起到作用。意思就是如果你在<code>//example.com/foo/bar.js</code>里注册了一个 <code>SW</code>，那么它默认的作用域为<code>//example.com/foo/</code>。</p>\n<h3 id="%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">生命周期<a class="anchor" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">§</a></h3>\n<h4 id="register">register<a class="anchor" href="#register">§</a></h4>\n<p><code>ServiceWorker.js</code>(又名<code>sw.js</code>)是一个独立 js，页面注册在浏览器支持的情况下，注册 sw.js 来控制<code>Service Worker</code>缓存。<code>register</code>将会触发安装声明周期。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token string">\'serviceWorker\'</span> <span class="token keyword">in</span> <span class="token dom variable">navigator</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token dom variable">navigator</span><span class="token punctuation">.</span><span class="token property-access">serviceWorker</span>\n    <span class="token punctuation">.</span><span class="token method function property-access">register</span><span class="token punctuation">(</span><span class="token string">\'/sw.js\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">registration</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>\n        <span class="token string">\'ServiceWorker registration successful with scope: \'</span><span class="token punctuation">,</span>\n        registration<span class="token punctuation">.</span><span class="token property-access">scope</span>\n      <span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token keyword control-flow">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">\'ServiceWorker registration failed: \'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h4 id="install">install<a class="anchor" href="#install">§</a></h4>\n<p><code>register</code>完成后会触发<code>install</code>的生命周期，把设置好的静态文件，采用<code>Service Worker</code>的缓存方式，使用了<code>Cache API</code>来将资源缓存起来，同时使用 <code>e.waitUntil</code> 接手一个<code>Promise</code>来等待资源缓存成功，等到这个<code>Promise</code>状态成功后，<code>ServiceWorker</code>进入<code>installed</code>状态，意味着安装完毕。这时候主线程中返回的<code>registration.waiting</code>属性代表进入<code>installed</code>状态的<code>ServiceWorker</code>。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token constant">CACHE_NAME</span> <span class="token operator">=</span> <span class="token string">\'my_cache\'</span>\n<span class="token keyword">var</span> urlsToCache <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">\'/index.html\'</span><span class="token punctuation">,</span> <span class="token string">\'/css/style.css\'</span><span class="token punctuation">,</span> <span class="token string">\'/js/script.js\'</span><span class="token punctuation">]</span>\n<span class="token comment">//这里的self代表ServiceWorkerGlobalScope</span>\nself<span class="token punctuation">.</span><span class="token method function property-access">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'install\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">//这里的waitUtil会在安装成功之前执行一些预装的操作，但是只建议做一些轻量级和非常重要资源的缓存，减少安装失败的概率。安装成功</span>\n  <span class="token comment">//后ServiceWorker状态会从installing变为installed</span>\n  event<span class="token punctuation">.</span><span class="token method function property-access">waitUntil</span><span class="token punctuation">(</span>\n    caches<span class="token punctuation">.</span><span class="token method function property-access">open</span><span class="token punctuation">(</span><span class="token constant">CACHE_NAME</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">cache</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">\'Opendhe : \'</span><span class="token punctuation">,</span> cache<span class="token punctuation">)</span>\n      <span class="token keyword control-flow">return</span> cache<span class="token punctuation">.</span><span class="token method function property-access">addAll</span><span class="token punctuation">(</span>urlsToCache<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h4 id="skipwaiting">skipWaiting<a class="anchor" href="#skipwaiting">§</a></h4>\n<p><code>skipWaiting()</code>意味着新 <code>SW</code> 控制了之前用旧 <code>SW</code> 获取的页面，也就是说你的页面有一部分资源是通过旧 <code>SW</code> 获取，剩下一部分是通过新 <code>SW</code> 获取.</p>\n<h4 id="activate">activate<a class="anchor" href="#activate">§</a></h4>\n<p>安装完，则会进入激活状态。如果之前已有<code>ServiceWorker</code>，这个版本只是对<code>ServiceWorker</code>进行了更新。如果你在<code>event.waitUntil()</code>中传入了一个 <code>Promise</code>，<code>SW</code> 将会缓存住功能性事件(<code>fetch</code>,<code>push</code>,<code>sync</code>等等)，直到 <code>Promise</code> 返回 <code>resolve</code> 的时候再触发，也就是说，当你的<code>fetch</code>事件被触发的时候，<code>SW</code> 已经被完全激活了。</p>\n<pre class="language-js"><code class="language-js">self<span class="token punctuation">.</span><span class="token method function property-access">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'activate\'</span><span class="token punctuation">,</span> <span class="token parameter">event</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n  event<span class="token punctuation">.</span><span class="token method function property-access">waitUntil</span><span class="token punctuation">(</span>\n    caches<span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token parameter">keys</span> <span class="token arrow operator">=></span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">all</span><span class="token punctuation">(</span>\n      keys<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>expectedCaches<span class="token punctuation">.</span><span class="token method function property-access">includes</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token keyword control-flow">return</span> caches<span class="token punctuation">.</span><span class="token method function property-access">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n      <span class="token comment">// V2控制缓存</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n<h4 id="fetch">fetch<a class="anchor" href="#fetch">§</a></h4>\n<p><code>fetch</code>请求是有别于<code>xhr</code>请求，<code>sw</code>提供监听拦截<code>fetch</code>的事件，对于命中缓存的数据可以直接返回请求。当接受到 <code>fetch</code> 请求时，会直接返回<code>event.respondWith</code> 得到<code>Promise</code> 结果。这样我们可以捕获页面所有的 <code>fetch</code> 请求。</p>\n<pre class="language-js"><code class="language-js">self<span class="token punctuation">.</span><span class="token method function property-access">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'fetch\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  event<span class="token punctuation">.</span><span class="token method function property-access">respondWith</span><span class="token punctuation">(</span>\n    caches<span class="token punctuation">.</span><span class="token method function property-access">match</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token property-access">request</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// Cache hit - return response</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token keyword control-flow">return</span> response<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword control-flow">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token property-access">request</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">)</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n<h4 id="redundant">Redundant<a class="anchor" href="#redundant">§</a></h4>\n<p><code>Service Worker</code> 可能因为以下之一的原因而被废弃（redundant，原意为“多余的，累赘的”）</p>\n<ul>\n<li><code>installing</code> 事件失败</li>\n<li><code>activating</code> 事件失败</li>\n<li>新的 <code>Service Worker</code> 替换其成为激活态 <code>worker</code></li>\n</ul>\n<p>浏览器获取了新版本的<code>ServiceWorker</code>代码，如果浏览器本身对<code>sw.js</code>进行缓存的话，也不会得到最新代码，所有代码会变成死代码，无法更新。所以对<code>sw</code>文件最好配置成<code>cache-control: no-cache</code>。</p>\n<h2 id="%E4%BC%98%E5%8C%96%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B">优化渲染过程<a class="anchor" href="#%E4%BC%98%E5%8C%96%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B">§</a></h2>\n<h3 id="%E6%87%92%E6%89%A7%E8%A1%8C">懒执行<a class="anchor" href="#%E6%87%92%E6%89%A7%E8%A1%8C">§</a></h3>\n<p>懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。</p>\n<h3 id="%E6%87%92%E5%8A%A0%E8%BD%BD">懒加载<a class="anchor" href="#%E6%87%92%E5%8A%A0%E8%BD%BD">§</a></h3>\n<p>懒加载就是将不关键的资源延后加载。\n懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。</p>\n<p>将页面里所有 img 属性 src 属性用 data-xx 代替，当页面滚动直至此图片出现在可视区域时，用 js 取到该图片的 data-xx 的值赋给 src，这样图片就会去下载资源，实现了图片懒加载。</p>\n<p>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。</p>\n<pre class="language-autoit"><code class="language-autoit">页可见区域宽： document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientWidth<span class="token comment">;</span>\n网页可见区域高： document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientHeight<span class="token comment">;</span>\n网页可见区域宽： document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>offsetWidth <span class="token punctuation">(</span>包括边线的宽<span class="token punctuation">)</span><span class="token comment">;</span>\n网页可见区域高： document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>offsetHeight <span class="token punctuation">(</span>包括边线的宽<span class="token punctuation">)</span><span class="token comment">;</span>\n网页正文全文宽： document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollWidth<span class="token comment">;</span>\n网页正文全文高： document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollHeight<span class="token comment">;</span>\n网页被卷去的高： document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollTop<span class="token comment">;</span>\n网页被卷去的左： document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollLeft<span class="token comment">;</span>\n网页正文部分上： window<span class="token punctuation">.</span>screenTop<span class="token comment">;</span>\n网页正文部分左： window<span class="token punctuation">.</span>screenLeft<span class="token comment">;</span>\n屏幕分辨率的高： window<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>height<span class="token comment">;</span>\n屏幕分辨率的宽： window<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>width<span class="token comment">;</span>\n屏幕可用工作区高度： window<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>availHeight<span class="token comment">;</span>\n</code></pre>\n<h2 id="%E6%96%87%E4%BB%B6%E4%BC%98%E5%8C%96">文件优化<a class="anchor" href="#%E6%96%87%E4%BB%B6%E4%BC%98%E5%8C%96">§</a></h2>\n<h3 id="%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96">图片优化<a class="anchor" href="#%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96">§</a></h3>\n<h4 id="%E8%AE%A1%E7%AE%97%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F">计算图片大小<a class="anchor" href="#%E8%AE%A1%E7%AE%97%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F">§</a></h4>\n<p>对于一张 100 * 100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1个字节），所以该图片大小大概为 39KB（10000 * 1 * 4 / 1024）。</p>\n<p>但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。</p>\n<p>了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了：</p>\n<ul>\n<li>减少像素点</li>\n<li>减少每个像素点能够显示的颜色</li>\n</ul>\n<h4 id="%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96">图片加载优化<a class="anchor" href="#%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96">§</a></h4>\n<ol>\n<li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</li>\n<li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li>\n<li>小图使用 base64 格式</li>\n<li>将多个图标文件整合到一张图片中（雪碧图）</li>\n<li>选择正确的图片格式：\n<ul>\n<li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li>\n<li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li>\n<li>照片使用 JPEG</li>\n</ul>\n</li>\n</ol>\n<h3 id="%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6%E4%BC%98%E5%8C%96">其他文件优化<a class="anchor" href="#%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6%E4%BC%98%E5%8C%96">§</a></h3>\n<ul>\n<li>CSS 文件放在 <code>head</code> 中</li>\n<li>服务端开启文件压缩功能</li>\n<li>将 <code>script</code> 标签放在 <code>body</code> 底部，因为 JS 文件执行会阻塞渲染。当然也可以把 <code>script</code> 标签放在任意位置然后加上 <code>defer</code> ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上 <code>async</code> ，表示加载和渲染后续文档元素的过程将和  JS 文件的加载与执行并行无序进行。</li>\n<li>执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 <code>Webworker</code>。<code>Webworker</code> 可以让我们另开一个线程执行脚本而不影响渲染。</li>\n</ul>\n<h3 id="cdn">CDN<a class="anchor" href="#cdn">§</a></h3>\n<p>静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。</p>'
        } }),
    'head': React.createElement(React.Fragment, null,
        React.createElement(React.Fragment, { key: ".0" },
            React.createElement("link", { href: "/favicon.png", rel: "icon", type: "image/png" }),
            React.createElement("script", { src: "/assets/custom.js" })),
        React.createElement("link", { crossOrigin: "anonymous", href: "https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css", integrity: "sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X", rel: "stylesheet" })),
    'script': React.createElement(React.Fragment, null,
        React.createElement("script", { src: "https://cdn.pagic.org/react@16.13.1/umd/react.production.min.js" }),
        React.createElement("script", { src: "https://cdn.pagic.org/react-dom@16.13.1/umd/react-dom.production.min.js" }),
        React.createElement("script", { src: "/index.js", type: "module" })),
    'contentTitle': React.createElement("h1", { key: "0", id: "%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" },
        "\u6027\u80FD\u4F18\u5316",
        React.createElement("a", { className: "anchor", href: "#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" }, "\u00A7")),
    'contentBody': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<h2 id="%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3">网络相关<a class="anchor" href="#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3">§</a></h2>\n<h3 id="dns-%E9%A2%84%E8%A7%A3%E6%9E%90">DNS 预解析<a class="anchor" href="#dns-%E9%A2%84%E8%A7%A3%E6%9E%90">§</a></h3>\n<p>DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。</p>\n<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dns-prefetch<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>//yuchengkai.cn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n</code></pre>\n<h3 id="%E7%BC%93%E5%AD%98">缓存<a class="anchor" href="#%E7%BC%93%E5%AD%98">§</a></h3>\n<p>缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。</p>\n<p>通常浏览器缓存策略分为两种：强缓存和协商缓存。</p>\n<h4 id="%E5%BC%BA%E7%BC%93%E5%AD%98">强缓存<a class="anchor" href="#%E5%BC%BA%E7%BC%93%E5%AD%98">§</a></h4>\n<p>实现强缓存可以通过两种响应头实现：<code>Expires</code> 和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，<code>state code</code> 为 200</p>\n<pre class="language-js"><code class="language-js"><span class="token maybe-class-name">Expires</span><span class="token operator">:</span> <span class="token maybe-class-name">Wed</span><span class="token punctuation">,</span> <span class="token number">22</span> <span class="token maybe-class-name">Oct</span> <span class="token number">2018</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">41</span><span class="token operator">:</span><span class="token number">00</span> <span class="token constant">GMT</span>\n</code></pre>\n<p><code>Expires</code> 是 HTTP / 1.0 的产物，表示资源会在 <code>Wed, 22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。并且 <code>Expires</code> 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p>\n<pre class="language-js"><code class="language-js"><span class="token maybe-class-name">Cache</span><span class="token operator">-</span>control<span class="token operator">:</span> max<span class="token operator">-</span>age<span class="token operator">=</span><span class="token number">30</span>\n</code></pre>\n<p><code>Cache-Control</code> 出现于 HTTP / 1.1，优先级高于 <code>Expires</code> 。该属性表示资源会在 30 秒后过期，需要再次请求。</p>\n<h4 id="%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98">协商缓存<a class="anchor" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98">§</a></h4>\n<p>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。</p>\n<p>协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。</p>\n<h5 id="last-modified-%E5%92%8C-if-modified-since">Last-Modified 和 If-Modified-Since<a class="anchor" href="#last-modified-%E5%92%8C-if-modified-since">§</a></h5>\n<p><code>Last-Modified</code> 表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified</code> 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。</p>\n<p>但是如果在本地打开缓存文件，就会造成 <code>Last-Modified</code> 被修改，所以在 HTTP / 1.1 出现了 <code>ETag</code> 。</p>\n<h5 id="etag-%E5%92%8C-if-none-match">ETag 和 If-None-Match<a class="anchor" href="#etag-%E5%92%8C-if-none-match">§</a></h5>\n<p><code>ETag</code> 类似于文件指纹，<code>If-None-Match</code> 会将当前 <code>ETag</code> 发送给服务器，询问该资源 <code>ETag</code> 是否变动，有变动的话就将新的资源发送回来。并且 <code>ETag</code> 优先级比 <code>Last-Modified</code> 高。</p>\n<h4 id="%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5">选择合适的缓存策略<a class="anchor" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5">§</a></h4>\n<p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p>\n<ul>\n<li>对于某些不需要缓存的资源，可以使用 <code>Cache-control: no-store</code> ，表示该资源不需要缓存</li>\n<li>对于频繁变动的资源，可以使用 <code>Cache-Control: no-cache</code> 并配合 <code>ETag</code> 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li>\n<li>对于代码文件来说，通常使用 <code>Cache-Control: max-age=31536000</code> 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li>\n</ul>\n<h3 id="%E4%BD%BF%E7%94%A8-http--20">使用 HTTP / 2.0<a class="anchor" href="#%E4%BD%BF%E7%94%A8-http--20">§</a></h3>\n<p>因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间。</p>\n<p>在  HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。</p>\n<h3 id="%E9%A2%84%E5%8A%A0%E8%BD%BD">预加载<a class="anchor" href="#%E9%A2%84%E5%8A%A0%E8%BD%BD">§</a></h3>\n<p>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。</p>\n<p>预加载其实是声明式的 <code>fetch</code> ，强制浏览器请求资源，并且不会阻塞 <code>onload</code> 事件，可以使用以下代码开启预加载</p>\n<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>preload<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><a class="token url-link" href="http://example.com">http://example.com</a><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n</code></pre>\n<p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</p>\n<h3 id="%E9%A2%84%E6%B8%B2%E6%9F%93">预渲染<a class="anchor" href="#%E9%A2%84%E6%B8%B2%E6%9F%93">§</a></h3>\n<p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染</p>\n<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>prerender<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><a class="token url-link" href="http://example.com">http://example.com</a><span class="token punctuation">"</span></span><span class="token punctuation">></span></span> \n</code></pre>\n<p>预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染</p>\n<h2 id="pwa-%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98">PWA 离线缓存<a class="anchor" href="#pwa-%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98">§</a></h2>\n<h3 id="%E4%B8%BB%E7%BA%BF%E7%A8%8B">主线程<a class="anchor" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B">§</a></h3>\n<p><code>ServiceWorker</code>既然命名为<code>worker</code>，很大一部分原因就是它和<code>WebWorker</code>相关。它是第二个线程，不会影响 dom 渲染的主线程，两个<code>Worker</code>之间的通讯是基于<code>postMessage</code>。\n<code>chrome://inspect/#service-workers</code> 就可以查看，在当前浏览器中，正在注册的 <code>SW</code>。另外，还有一个 <code>chrome://serviceworker-internals</code>，用来查看当前浏览器中，所有注册好的 <code>SW</code>。</p>\n<h3 id="%E5%9F%BA%E4%BA%8E-https">基于 HTTPS<a class="anchor" href="#%E5%9F%BA%E4%BA%8E-https">§</a></h3>\n<p><code>SW</code> 是基于 <code>HTTPS</code> 的，如果你的网站不是 <code>HTTPS</code>，那么基本上你也别想了 <code>SW</code>。</p>\n<h3 id="scope-%E4%BD%9C%E7%94%A8%E5%9F%9F">Scope 作用域<a class="anchor" href="#scope-%E4%BD%9C%E7%94%A8%E5%9F%9F">§</a></h3>\n<p>一个<code>sw.js</code>并不能接管一个站点所有的页面，它只能在所在路由底下起到作用。意思就是如果你在<code>//example.com/foo/bar.js</code>里注册了一个 <code>SW</code>，那么它默认的作用域为<code>//example.com/foo/</code>。</p>\n<h3 id="%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">生命周期<a class="anchor" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">§</a></h3>\n<h4 id="register">register<a class="anchor" href="#register">§</a></h4>\n<p><code>ServiceWorker.js</code>(又名<code>sw.js</code>)是一个独立 js，页面注册在浏览器支持的情况下，注册 sw.js 来控制<code>Service Worker</code>缓存。<code>register</code>将会触发安装声明周期。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token string">\'serviceWorker\'</span> <span class="token keyword">in</span> <span class="token dom variable">navigator</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token dom variable">navigator</span><span class="token punctuation">.</span><span class="token property-access">serviceWorker</span>\n    <span class="token punctuation">.</span><span class="token method function property-access">register</span><span class="token punctuation">(</span><span class="token string">\'/sw.js\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">registration</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>\n        <span class="token string">\'ServiceWorker registration successful with scope: \'</span><span class="token punctuation">,</span>\n        registration<span class="token punctuation">.</span><span class="token property-access">scope</span>\n      <span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token keyword control-flow">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">\'ServiceWorker registration failed: \'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h4 id="install">install<a class="anchor" href="#install">§</a></h4>\n<p><code>register</code>完成后会触发<code>install</code>的生命周期，把设置好的静态文件，采用<code>Service Worker</code>的缓存方式，使用了<code>Cache API</code>来将资源缓存起来，同时使用 <code>e.waitUntil</code> 接手一个<code>Promise</code>来等待资源缓存成功，等到这个<code>Promise</code>状态成功后，<code>ServiceWorker</code>进入<code>installed</code>状态，意味着安装完毕。这时候主线程中返回的<code>registration.waiting</code>属性代表进入<code>installed</code>状态的<code>ServiceWorker</code>。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token constant">CACHE_NAME</span> <span class="token operator">=</span> <span class="token string">\'my_cache\'</span>\n<span class="token keyword">var</span> urlsToCache <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">\'/index.html\'</span><span class="token punctuation">,</span> <span class="token string">\'/css/style.css\'</span><span class="token punctuation">,</span> <span class="token string">\'/js/script.js\'</span><span class="token punctuation">]</span>\n<span class="token comment">//这里的self代表ServiceWorkerGlobalScope</span>\nself<span class="token punctuation">.</span><span class="token method function property-access">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'install\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">//这里的waitUtil会在安装成功之前执行一些预装的操作，但是只建议做一些轻量级和非常重要资源的缓存，减少安装失败的概率。安装成功</span>\n  <span class="token comment">//后ServiceWorker状态会从installing变为installed</span>\n  event<span class="token punctuation">.</span><span class="token method function property-access">waitUntil</span><span class="token punctuation">(</span>\n    caches<span class="token punctuation">.</span><span class="token method function property-access">open</span><span class="token punctuation">(</span><span class="token constant">CACHE_NAME</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">cache</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">\'Opendhe : \'</span><span class="token punctuation">,</span> cache<span class="token punctuation">)</span>\n      <span class="token keyword control-flow">return</span> cache<span class="token punctuation">.</span><span class="token method function property-access">addAll</span><span class="token punctuation">(</span>urlsToCache<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h4 id="skipwaiting">skipWaiting<a class="anchor" href="#skipwaiting">§</a></h4>\n<p><code>skipWaiting()</code>意味着新 <code>SW</code> 控制了之前用旧 <code>SW</code> 获取的页面，也就是说你的页面有一部分资源是通过旧 <code>SW</code> 获取，剩下一部分是通过新 <code>SW</code> 获取.</p>\n<h4 id="activate">activate<a class="anchor" href="#activate">§</a></h4>\n<p>安装完，则会进入激活状态。如果之前已有<code>ServiceWorker</code>，这个版本只是对<code>ServiceWorker</code>进行了更新。如果你在<code>event.waitUntil()</code>中传入了一个 <code>Promise</code>，<code>SW</code> 将会缓存住功能性事件(<code>fetch</code>,<code>push</code>,<code>sync</code>等等)，直到 <code>Promise</code> 返回 <code>resolve</code> 的时候再触发，也就是说，当你的<code>fetch</code>事件被触发的时候，<code>SW</code> 已经被完全激活了。</p>\n<pre class="language-js"><code class="language-js">self<span class="token punctuation">.</span><span class="token method function property-access">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'activate\'</span><span class="token punctuation">,</span> <span class="token parameter">event</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n  event<span class="token punctuation">.</span><span class="token method function property-access">waitUntil</span><span class="token punctuation">(</span>\n    caches<span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token parameter">keys</span> <span class="token arrow operator">=></span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">all</span><span class="token punctuation">(</span>\n      keys<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>expectedCaches<span class="token punctuation">.</span><span class="token method function property-access">includes</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token keyword control-flow">return</span> caches<span class="token punctuation">.</span><span class="token method function property-access">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n      <span class="token comment">// V2控制缓存</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n<h4 id="fetch">fetch<a class="anchor" href="#fetch">§</a></h4>\n<p><code>fetch</code>请求是有别于<code>xhr</code>请求，<code>sw</code>提供监听拦截<code>fetch</code>的事件，对于命中缓存的数据可以直接返回请求。当接受到 <code>fetch</code> 请求时，会直接返回<code>event.respondWith</code> 得到<code>Promise</code> 结果。这样我们可以捕获页面所有的 <code>fetch</code> 请求。</p>\n<pre class="language-js"><code class="language-js">self<span class="token punctuation">.</span><span class="token method function property-access">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'fetch\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  event<span class="token punctuation">.</span><span class="token method function property-access">respondWith</span><span class="token punctuation">(</span>\n    caches<span class="token punctuation">.</span><span class="token method function property-access">match</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token property-access">request</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// Cache hit - return response</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token keyword control-flow">return</span> response<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword control-flow">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token property-access">request</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">)</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n<h4 id="redundant">Redundant<a class="anchor" href="#redundant">§</a></h4>\n<p><code>Service Worker</code> 可能因为以下之一的原因而被废弃（redundant，原意为“多余的，累赘的”）</p>\n<ul>\n<li><code>installing</code> 事件失败</li>\n<li><code>activating</code> 事件失败</li>\n<li>新的 <code>Service Worker</code> 替换其成为激活态 <code>worker</code></li>\n</ul>\n<p>浏览器获取了新版本的<code>ServiceWorker</code>代码，如果浏览器本身对<code>sw.js</code>进行缓存的话，也不会得到最新代码，所有代码会变成死代码，无法更新。所以对<code>sw</code>文件最好配置成<code>cache-control: no-cache</code>。</p>\n<h2 id="%E4%BC%98%E5%8C%96%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B">优化渲染过程<a class="anchor" href="#%E4%BC%98%E5%8C%96%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B">§</a></h2>\n<h3 id="%E6%87%92%E6%89%A7%E8%A1%8C">懒执行<a class="anchor" href="#%E6%87%92%E6%89%A7%E8%A1%8C">§</a></h3>\n<p>懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。</p>\n<h3 id="%E6%87%92%E5%8A%A0%E8%BD%BD">懒加载<a class="anchor" href="#%E6%87%92%E5%8A%A0%E8%BD%BD">§</a></h3>\n<p>懒加载就是将不关键的资源延后加载。\n懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。</p>\n<p>将页面里所有 img 属性 src 属性用 data-xx 代替，当页面滚动直至此图片出现在可视区域时，用 js 取到该图片的 data-xx 的值赋给 src，这样图片就会去下载资源，实现了图片懒加载。</p>\n<p>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。</p>\n<pre class="language-autoit"><code class="language-autoit">页可见区域宽： document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientWidth<span class="token comment">;</span>\n网页可见区域高： document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientHeight<span class="token comment">;</span>\n网页可见区域宽： document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>offsetWidth <span class="token punctuation">(</span>包括边线的宽<span class="token punctuation">)</span><span class="token comment">;</span>\n网页可见区域高： document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>offsetHeight <span class="token punctuation">(</span>包括边线的宽<span class="token punctuation">)</span><span class="token comment">;</span>\n网页正文全文宽： document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollWidth<span class="token comment">;</span>\n网页正文全文高： document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollHeight<span class="token comment">;</span>\n网页被卷去的高： document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollTop<span class="token comment">;</span>\n网页被卷去的左： document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollLeft<span class="token comment">;</span>\n网页正文部分上： window<span class="token punctuation">.</span>screenTop<span class="token comment">;</span>\n网页正文部分左： window<span class="token punctuation">.</span>screenLeft<span class="token comment">;</span>\n屏幕分辨率的高： window<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>height<span class="token comment">;</span>\n屏幕分辨率的宽： window<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>width<span class="token comment">;</span>\n屏幕可用工作区高度： window<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>availHeight<span class="token comment">;</span>\n</code></pre>\n<h2 id="%E6%96%87%E4%BB%B6%E4%BC%98%E5%8C%96">文件优化<a class="anchor" href="#%E6%96%87%E4%BB%B6%E4%BC%98%E5%8C%96">§</a></h2>\n<h3 id="%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96">图片优化<a class="anchor" href="#%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96">§</a></h3>\n<h4 id="%E8%AE%A1%E7%AE%97%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F">计算图片大小<a class="anchor" href="#%E8%AE%A1%E7%AE%97%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F">§</a></h4>\n<p>对于一张 100 * 100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1个字节），所以该图片大小大概为 39KB（10000 * 1 * 4 / 1024）。</p>\n<p>但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。</p>\n<p>了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了：</p>\n<ul>\n<li>减少像素点</li>\n<li>减少每个像素点能够显示的颜色</li>\n</ul>\n<h4 id="%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96">图片加载优化<a class="anchor" href="#%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96">§</a></h4>\n<ol>\n<li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</li>\n<li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li>\n<li>小图使用 base64 格式</li>\n<li>将多个图标文件整合到一张图片中（雪碧图）</li>\n<li>选择正确的图片格式：\n<ul>\n<li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li>\n<li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li>\n<li>照片使用 JPEG</li>\n</ul>\n</li>\n</ol>\n<h3 id="%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6%E4%BC%98%E5%8C%96">其他文件优化<a class="anchor" href="#%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6%E4%BC%98%E5%8C%96">§</a></h3>\n<ul>\n<li>CSS 文件放在 <code>head</code> 中</li>\n<li>服务端开启文件压缩功能</li>\n<li>将 <code>script</code> 标签放在 <code>body</code> 底部，因为 JS 文件执行会阻塞渲染。当然也可以把 <code>script</code> 标签放在任意位置然后加上 <code>defer</code> ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上 <code>async</code> ，表示加载和渲染后续文档元素的过程将和  JS 文件的加载与执行并行无序进行。</li>\n<li>执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 <code>Webworker</code>。<code>Webworker</code> 可以让我们另开一个线程执行脚本而不影响渲染。</li>\n</ul>\n<h3 id="cdn">CDN<a class="anchor" href="#cdn">§</a></h3>\n<p>静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。</p>'
        } }),
    'toc': React.createElement("nav", { key: "0", className: "toc" },
        React.createElement("ol", null,
            React.createElement("li", null,
                React.createElement("a", { href: "#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" }, "\u6027\u80FD\u4F18\u5316"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3" }, "\u7F51\u7EDC\u76F8\u5173"),
                        React.createElement("ol", null,
                            React.createElement("li", null,
                                React.createElement("a", { href: "#dns-%E9%A2%84%E8%A7%A3%E6%9E%90" }, "DNS \u9884\u89E3\u6790")),
                            React.createElement("li", null,
                                React.createElement("a", { href: "#%E7%BC%93%E5%AD%98" }, "\u7F13\u5B58"),
                                React.createElement("ol", null,
                                    React.createElement("li", null,
                                        React.createElement("a", { href: "#%E5%BC%BA%E7%BC%93%E5%AD%98" }, "\u5F3A\u7F13\u5B58")),
                                    React.createElement("li", null,
                                        React.createElement("a", { href: "#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98" }, "\u534F\u5546\u7F13\u5B58"),
                                        React.createElement("ol", null)),
                                    React.createElement("li", null,
                                        React.createElement("a", { href: "#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5" }, "\u9009\u62E9\u5408\u9002\u7684\u7F13\u5B58\u7B56\u7565")))),
                            React.createElement("li", null,
                                React.createElement("a", { href: "#%E4%BD%BF%E7%94%A8-http--20" }, "\u4F7F\u7528 HTTP / 2.0")),
                            React.createElement("li", null,
                                React.createElement("a", { href: "#%E9%A2%84%E5%8A%A0%E8%BD%BD" }, "\u9884\u52A0\u8F7D")),
                            React.createElement("li", null,
                                React.createElement("a", { href: "#%E9%A2%84%E6%B8%B2%E6%9F%93" }, "\u9884\u6E32\u67D3")))),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#pwa-%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98" }, "PWA \u79BB\u7EBF\u7F13\u5B58"),
                        React.createElement("ol", null,
                            React.createElement("li", null,
                                React.createElement("a", { href: "#%E4%B8%BB%E7%BA%BF%E7%A8%8B" }, "\u4E3B\u7EBF\u7A0B")),
                            React.createElement("li", null,
                                React.createElement("a", { href: "#%E5%9F%BA%E4%BA%8E-https" }, "\u57FA\u4E8E HTTPS")),
                            React.createElement("li", null,
                                React.createElement("a", { href: "#scope-%E4%BD%9C%E7%94%A8%E5%9F%9F" }, "Scope \u4F5C\u7528\u57DF")),
                            React.createElement("li", null,
                                React.createElement("a", { href: "#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" }, "\u751F\u547D\u5468\u671F"),
                                React.createElement("ol", null,
                                    React.createElement("li", null,
                                        React.createElement("a", { href: "#register" }, "register")),
                                    React.createElement("li", null,
                                        React.createElement("a", { href: "#install" }, "install")),
                                    React.createElement("li", null,
                                        React.createElement("a", { href: "#skipwaiting" }, "skipWaiting")),
                                    React.createElement("li", null,
                                        React.createElement("a", { href: "#activate" }, "activate")),
                                    React.createElement("li", null,
                                        React.createElement("a", { href: "#fetch" }, "fetch")),
                                    React.createElement("li", null,
                                        React.createElement("a", { href: "#redundant" }, "Redundant")))))),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E4%BC%98%E5%8C%96%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B" }, "\u4F18\u5316\u6E32\u67D3\u8FC7\u7A0B"),
                        React.createElement("ol", null,
                            React.createElement("li", null,
                                React.createElement("a", { href: "#%E6%87%92%E6%89%A7%E8%A1%8C" }, "\u61D2\u6267\u884C")),
                            React.createElement("li", null,
                                React.createElement("a", { href: "#%E6%87%92%E5%8A%A0%E8%BD%BD" }, "\u61D2\u52A0\u8F7D")))),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E6%96%87%E4%BB%B6%E4%BC%98%E5%8C%96" }, "\u6587\u4EF6\u4F18\u5316"),
                        React.createElement("ol", null,
                            React.createElement("li", null,
                                React.createElement("a", { href: "#%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96" }, "\u56FE\u7247\u4F18\u5316"),
                                React.createElement("ol", null,
                                    React.createElement("li", null,
                                        React.createElement("a", { href: "#%E8%AE%A1%E7%AE%97%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F" }, "\u8BA1\u7B97\u56FE\u7247\u5927\u5C0F")),
                                    React.createElement("li", null,
                                        React.createElement("a", { href: "#%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96" }, "\u56FE\u7247\u52A0\u8F7D\u4F18\u5316")))),
                            React.createElement("li", null,
                                React.createElement("a", { href: "#%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6%E4%BC%98%E5%8C%96" }, "\u5176\u4ED6\u6587\u4EF6\u4F18\u5316")),
                            React.createElement("li", null,
                                React.createElement("a", { href: "#cdn" }, "CDN")))))))),
    'author': "wangweidong",
    'contributors': [
        "wangweidong"
    ],
    'date': "2021-02-02T09:45:54.000Z",
    'updated': null,
    'excerpt': "网络相关 DNS 预解析 DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。 <link rel=\"dns-prefetch\" href=\"//yuchengkai.cn\"> 缓存 缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资...",
    'cover': undefined,
    'sidebar': [
        {
            "text": "CSS 入门",
            "link": "start/CSS.html",
            "pagePath": "start/CSS.md"
        },
        {
            "text": "CSS3新特性",
            "link": "start/CSS3.html",
            "pagePath": "start/CSS3.md"
        },
        {
            "text": "深入 JavaScript",
            "link": "start/JS.html",
            "pagePath": "start/JS.md"
        },
        {
            "text": "移动端常见问题",
            "link": "start/Mobile.html",
            "pagePath": "start/Mobile.md"
        },
        {
            "text": "性能优化",
            "link": "start/Performance.html",
            "pagePath": "start/Performance.md"
        },
        {
            "text": "代码重构经验",
            "link": "start/Codeing.html",
            "pagePath": "start/Codeing.md"
        },
        {
            "text": "Mobx",
            "link": "start/Mobx.html",
            "pagePath": "start/Mobx.md"
        }
    ],
    'blog': {
        "isPost": false,
        "posts": [],
        "categories": [],
        "tags": []
    },
    'gitalk': React.createElement(Gitalk, { admin: [
            'ViktorWong'
        ], clientID: "0af8ad0c8674b58c37c0", clientSecret: "fe697a9667fc2b49387bf550e4178b3eaa5b8859", id: "start/Performance.html", owner: "ViktorWong", repo: "my-docs", title: "\u6027\u80FD\u4F18\u5316" })
};
